#ifndef __FLUC_UTILS_LEXER_HH__
#define __FLUC_UTILS_LEXER_HH__

#include "automata.hh"
#include <vector>
#include <iostream>


namespace Fluc {
namespace Utils {

/**
 * Represents a single token.
 *
 * @ingroup utils
 */
class Token
{
public:
  /**
   * Defines the default token-ids.
   */
  typedef enum {
    END_OF_INPUT = 0,          ///< A token representing the end-of-input.
    FIRST_USER_DEFINED = 256   ///< The first non-reseved token-id.
  } Id;


protected:
  /**
   * Holds the token type.
   */
  unsigned id;

  /**
   * Holds the line of the token.
   */
  size_t line;

  /**
   * Holds the value of the token.
   */
  std::string value;


public:
  /**
   * Constructs an empty token (END_OF_INPUT).
   */
  Token();

  /**
   * Constructs a token from given identifier, line and value.
   */
  Token(unsigned id, size_t line, const std::string &value);

  /**
   * Returns the identifier of the token.
   */
  unsigned getId() const;

  /**
   * Returns the line of the token.
   */
  unsigned int getLine() const;

  /**
   * Returns the value of the token.
   */
  const std::string &getValue() const;
};



/**
 * Base class of all token-rules.
 *
 * @ingroup utils
 */
class TokenRule : public DFA
{
protected:
  /**
   * Id of the token.
   */
  unsigned id;

public:
  /**
   * Constructs a token-rule.
   */
  TokenRule(unsigned id, bool initial_is_final=false);

  /**
   * Constructs a token from match.
   */
  Token getToken(size_t line) const;

  /**
   * Returns the id of the tokens generated by this rule.
   */
  unsigned getId() const;
};



/**
 * Implements a general lexer.
 *
 * @ingroup utils
 */
class Lexer
{
public:
  /**
   * Simple class to hold the lexer state.
   */
  class State {
  public:
    /**
     * Holds the index of the current token.
     */
    size_t idx;

    /**
     * Holds the current line number.
     */
    size_t line;

    /**
     * Holds the current column number.
     */
    size_t column;

  public:
    /**
     * Constructor.
     */
    State(size_t idx, size_t line, size_t column)
      : idx(idx), line(line), column(column)
    {
      // Pass...
    }
  };


protected:
  /**
   * Holds a weak reference to the input stream.
   */
  std::istream &input;

  /**
   * Holds the vector of tokens.
   */
  std::vector< Token > history;

  /**
   * Holds stack of states.
   */
  std::list<State> stack;

  /**
   * The @c NFA to process input.
   */
  NFA reader;

  /**
   * A set of ignored token.
   */
  std::set<unsigned> ignored_token;

  /**
   * A set of tokens marking a new-line.
   */
  std::set<unsigned> new_line_token;

  /**
   * Holds a translation-table Token-ID -> name. Used for debug and exceptions.
   */
  std::map<unsigned, std::string> token_table;


public:
  /**
   * Constructs a general lexer for the given input.
   */
  Lexer(std::istream &input);

  /**
   * Adds a rule to the lexer.
   *
   * @note The ownership of the rule is taken by the lexer.
   */
  void addRule(TokenRule *token);

  /**
   * Returns the next token, reads it from input if needed.
   */
  const Token &next();

  /**
   * Returns the current token.
   *
   * If the first token was not read from the input yet, it will be read.
   */
  const Token &current();

  size_t currentIndex() const;

  /**
   * Saves the current state on the stack.
   */
  void push_state();

  /**
   * Drops the previous state.
   */
  void drop_state();

  /**
   * Restores the previous state.
   */
  void restore_state();

  /**
   * Resets the lexer, conserves parsed tokens in history.
   */
  void reset();

  /**
   * Registers a name for the token-id.
   */
  void addTokenName(unsigned id, const std::string &name);

  /**
   * Returns the name for the token or "Token(ID)" if no name is registered.
   */
  std::string getTokenName(unsigned id);

  /** Returns the i-th parsed token. */
  const Token &operator[] (size_t idx) const;


protected:
  /**
   * Parses the next token from input.
   */
  void parseToken();
};



}
}

#endif // LEXER_HH
